<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entailment Hypergraph Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f1419;
            --bg-secondary: #1a1f2e;
            --bg-tertiary: #252b3b;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --border: #30363d;
            --accent: #58a6ff;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 2rem;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        select, button {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 0.6rem 1rem;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        button:hover, select:hover {
            border-color: var(--accent);
        }

        button:active {
            transform: translateY(1px);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 2rem;
        }

        .viz-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 1rem;
            position: relative;
            min-height: 600px;
        }

        #graph {
            width: 100%;
            height: 800px;
            border-radius: 6px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
        }

        .panel-title {
            color: var(--accent);
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
        }

        .claim-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .claim-card:hover {
            border-color: var(--accent);
            background: #2d3548;
        }

        .claim-card.selected {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.2);
        }

        .claim-id {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .claim-text {
            font-size: 0.9rem;
            line-height: 1.5;
            margin-bottom: 0.5rem;
        }

        .claim-score {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .score-high { background: rgba(63, 185, 80, 0.2); color: var(--success); }
        .score-medium { background: rgba(210, 153, 34, 0.2); color: var(--warning); }
        .score-low { background: rgba(248, 81, 73, 0.2); color: var(--danger); }

        .implication-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-left: 3px solid var(--accent);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }

        .impl-id {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .impl-formula {
            font-family: 'SF Mono', Monaco, monospace;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .impl-reasoning {
            color: var(--text-secondary);
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .legend {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid;
        }

        .legend-line {
            width: 30px;
            height: 2px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Entailment Hypergraph Visualizer</h1>
            <div class="subtitle">Atomic claims as nodes, implications as hyperedges</div>
        </header>

        <div class="controls">
            <select id="example-select">
                <option value="/entailment_hypergraph/water_boiling_example.json">Water Boiling (Simple)</option>
                <option value="/entailment_hypergraph/steam_engine_example.json">Steam Engine Feasibility (Complex)</option>
            </select>
            <button id="reset-view">Reset View</button>
            <button id="toggle-physics">Toggle Physics</button>
            <button id="toggle-text">Full Text</button>
            <button id="zoom-in">Zoom In</button>
            <button id="zoom-out">Zoom Out</button>
            <button id="zoom-reset">Reset Zoom</button>
        </div>

        <div class="main-content">
            <div class="viz-container">
                <svg id="graph"></svg>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <div class="panel-title">Claims (Nodes)</div>
                    <div id="claims-list"></div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-circle" style="border-color: #3fb950; background: rgba(63, 185, 80, 0.2);"></div>
                            <span>High (7.5-10)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-circle" style="border-color: #d29922; background: rgba(210, 153, 34, 0.2);"></div>
                            <span>Medium (5-7.5)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-circle" style="border-color: #f85149; background: rgba(248, 81, 73, 0.2);"></div>
                            <span>Low (0-5)</span>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Implications (Hyperedges)</div>
                    <div id="implications-list"></div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-circle" style="width: 12px; height: 12px; border-color: #58a6ff; background: #58a6ff;"></div>
                            <span>AND junction (∧)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: #8b949e;"></div>
                            <span>Premise edges</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: #58a6ff; height: 3px;"></div>
                            <span>Conclusion edge</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let hypergraph = null;
        let selectedClaim = null;
        let simulation = null;
        let physicsEnabled = true;
        let fullTextMode = false;
        let zoom = null;
        let svg = null;
        let g = null;

        // Collapse state
        let collapsedNodes = new Set(); // Node IDs that are currently hidden
        let conclusionToPremises = new Map(); // conclusion ID -> [premise IDs]

        // Load initial example
        loadExample('/entailment_hypergraph/water_boiling_example.json');

        // Event listeners
        document.getElementById('example-select').addEventListener('change', (e) => {
            loadExample(e.target.value);
        });

        document.getElementById('reset-view').addEventListener('click', resetView);
        document.getElementById('toggle-physics').addEventListener('click', togglePhysics);
        document.getElementById('toggle-text').addEventListener('click', toggleTextMode);
        document.getElementById('zoom-in').addEventListener('click', () => zoomBy(1.3));
        document.getElementById('zoom-out').addEventListener('click', () => zoomBy(0.7));
        document.getElementById('zoom-reset').addEventListener('click', resetZoom);

        async function loadExample(path) {
            try {
                const response = await fetch(path);
                hypergraph = await response.json();
                collapsedNodes.clear(); // Reset collapse state
                buildImplicationMap();
                renderHypergraph();
                renderSidebar();
            } catch (error) {
                console.error('Error loading example:', error);
            }
        }

        function buildImplicationMap() {
            conclusionToPremises.clear();
            hypergraph.implications.forEach(impl => {
                conclusionToPremises.set(impl.conclusion, impl.premises);
            });
        }

        function isConclusion(nodeId) {
            return conclusionToPremises.has(nodeId);
        }

        function arePremisesCollapsed(conclusionId) {
            const premises = conclusionToPremises.get(conclusionId);
            if (!premises || premises.length === 0) return false;
            return premises.some(p => collapsedNodes.has(p));
        }

        function toggleCollapse(conclusionId) {
            const premises = conclusionToPremises.get(conclusionId);
            if (!premises) return; // Not a conclusion, nothing to collapse

            const currentlyCollapsed = arePremisesCollapsed(conclusionId);

            if (currentlyCollapsed) {
                // Expand - show immediate premises only
                premises.forEach(p => collapsedNodes.delete(p));
            } else {
                // Collapse - recursively hide all premises and their sub-premises
                collapseRecursive(conclusionId);
            }

            // Re-render graph
            renderHypergraph();
        }

        function collapseRecursive(nodeId) {
            const premises = conclusionToPremises.get(nodeId);
            if (!premises) return;

            premises.forEach(premiseId => {
                collapsedNodes.add(premiseId);
                // Recursively collapse if this premise is also a conclusion
                if (isConclusion(premiseId)) {
                    collapseRecursive(premiseId);
                }
            });
        }

        function getScoreColor(score) {
            if (score >= 7.5) return '#3fb950';
            if (score >= 5) return '#d29922';
            return '#f85149';
        }

        function getScoreClass(score) {
            if (score >= 7.5) return 'score-high';
            if (score >= 5) return 'score-medium';
            return 'score-low';
        }

        function renderSidebar() {
            // Render claims
            const claimsList = document.getElementById('claims-list');
            claimsList.innerHTML = hypergraph.claims.map(claim => `
                <div class="claim-card" data-claim-id="${claim.id}">
                    <div class="claim-id">${claim.id}</div>
                    <div class="claim-text">${claim.text}</div>
                    <span class="claim-score ${getScoreClass(claim.score)}">${claim.score}/10</span>
                </div>
            `).join('');

            // Add click handlers
            document.querySelectorAll('.claim-card').forEach(card => {
                card.addEventListener('click', () => {
                    const claimId = card.dataset.claimId;
                    selectClaim(claimId);
                });
            });

            // Render implications
            const implList = document.getElementById('implications-list');
            implList.innerHTML = hypergraph.implications.map(impl => {
                const premiseIds = impl.premises.join(', ');
                const formula = `(${premiseIds}) → ${impl.conclusion}`;
                return `
                    <div class="implication-item">
                        <div class="impl-id">${impl.id}</div>
                        <div class="impl-formula">${formula}</div>
                        <div class="impl-reasoning">${impl.reasoning}</div>
                    </div>
                `;
            }).join('');
        }

        function selectClaim(claimId) {
            selectedClaim = claimId;

            // Update UI
            document.querySelectorAll('.claim-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.claimId === claimId);
            });

            // Highlight in graph
            highlightClaim(claimId);
        }

        function highlightClaim(claimId) {
            d3.selectAll('.claim-node')
                .attr('opacity', d => d.id === claimId ? 1 : 0.3)
                .attr('stroke-width', d => d.id === claimId ? 4 : 2);

            d3.selectAll('.hyperedge')
                .attr('opacity', d => {
                    return d.premises.includes(claimId) || d.conclusion === claimId ? 1 : 0.2;
                });
        }

        function renderHypergraph() {
            const width = document.getElementById('graph').clientWidth;
            const height = 800;

            // Clear existing
            d3.select('#graph').selectAll('*').remove();

            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);

            // Create container group for zoom/pan
            g = svg.append('g');

            // Setup zoom behavior
            zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Create nodes: claims + junction nodes for implications
            const claims = hypergraph.claims.map(c => ({...c, type: 'claim'}));
            const junctions = hypergraph.implications.map((impl, i) => ({
                id: `junction_${impl.id}`,
                type: 'junction',
                implication: impl
            }));

            // Filter out collapsed nodes
            const visibleClaims = claims.filter(c => !collapsedNodes.has(c.id));
            const visibleJunctions = junctions.filter(j => {
                // Hide junction if any of its premises or conclusion are collapsed
                const impl = j.implication;
                return !collapsedNodes.has(impl.conclusion) &&
                       !impl.premises.some(p => collapsedNodes.has(p));
            });

            const allNodes = [...visibleClaims, ...visibleJunctions];

            // Create links
            const links = [];

            // Links from premises to junctions (only for visible nodes)
            hypergraph.implications.forEach(impl => {
                const junctionId = `junction_${impl.id}`;

                // Skip if conclusion or any premise is collapsed
                if (collapsedNodes.has(impl.conclusion) ||
                    impl.premises.some(p => collapsedNodes.has(p))) {
                    return;
                }

                impl.premises.forEach(premise => {
                    links.push({
                        source: premise,
                        target: junctionId,
                        type: 'premise-to-junction'
                    });
                });

                // Link from junction to conclusion
                links.push({
                    source: junctionId,
                    target: impl.conclusion,
                    type: 'junction-to-conclusion'
                });
            });

            // Calculate hierarchical levels for tree-like layout
            // Start from root conclusions and work downward
            const levels = new Map();

            // Find root conclusions (nodes that are conclusions but not premises of anything)
            const allPremises = new Set();
            hypergraph.implications.forEach(impl => {
                impl.premises.forEach(p => allPremises.add(p));
            });

            const rootConclusions = visibleClaims
                .filter(c => conclusionToPremises.has(c.id)) // Is a conclusion
                .filter(c => !allPremises.has(c.id)) // Not used as premise
                .map(c => c.id);

            // Start roots at level 0 (top)
            rootConclusions.forEach(rootId => {
                levels.set(rootId, 0);
            });

            // If no roots found (disconnected graph), use all conclusions
            if (rootConclusions.length === 0) {
                visibleClaims
                    .filter(c => conclusionToPremises.has(c.id))
                    .forEach(c => levels.set(c.id, 0));
            }

            // Iteratively assign levels working downward (from conclusions to premises)
            let changed = true;
            let iterations = 0;
            while (changed && iterations < 20) {
                changed = false;
                iterations++;

                hypergraph.implications.forEach(impl => {
                    // Skip if conclusion or any premise is collapsed
                    if (collapsedNodes.has(impl.conclusion) ||
                        impl.premises.some(p => collapsedNodes.has(p))) {
                        return;
                    }

                    const conclusionLevel = levels.get(impl.conclusion);

                    if (conclusionLevel !== undefined) {
                        const junctionId = `junction_${impl.id}`;
                        const junctionLevel = conclusionLevel + 1;
                        const premiseLevel = conclusionLevel + 2;

                        // Set junction level
                        if (!levels.has(junctionId)) {
                            levels.set(junctionId, junctionLevel);
                            changed = true;
                        }

                        // Set premise levels (or update if this path is deeper)
                        impl.premises.forEach(premiseId => {
                            if (!levels.has(premiseId) || levels.get(premiseId) < premiseLevel) {
                                levels.set(premiseId, premiseLevel);
                                changed = true;
                            }
                        });
                    }
                });
            }

            // Assign y-positions based on levels (level 0 at top, increasing downward)
            const maxLevel = Math.max(...Array.from(levels.values()), 0);
            const levelSpacing = (height - 200) / (maxLevel + 1);

            allNodes.forEach(node => {
                const level = levels.get(node.id) || 0;
                node.targetY = 100 + (level * levelSpacing); // Top to bottom

                // Set initial x position to center if not already set
                if (node.x === undefined) {
                    node.x = width / 2 + (Math.random() - 0.5) * 100;
                }
                if (node.y === undefined) {
                    node.y = node.targetY;
                }
            });

            // Custom force to position junctions at the centroid of connected nodes
            function junctionCentroidForce() {
                let nodes;

                function force(alpha) {
                    nodes.forEach(node => {
                        if (node.type === 'junction') {
                            const impl = node.implication;

                            // Find premise and conclusion nodes
                            const premiseNodes = impl.premises
                                .map(id => nodes.find(n => n.id === id))
                                .filter(n => n);
                            const conclusionNode = nodes.find(n => n.id === impl.conclusion);

                            if (premiseNodes.length > 0 && conclusionNode) {
                                // Calculate centroid of premises and conclusion
                                const allConnected = [...premiseNodes, conclusionNode];
                                const centroidX = allConnected.reduce((sum, n) => sum + n.x, 0) / allConnected.length;
                                const centroidY = allConnected.reduce((sum, n) => sum + n.y, 0) / allConnected.length;

                                // Pull junction towards centroid
                                const strength = 0.2 * alpha;
                                node.vx += (centroidX - node.x) * strength;
                                node.vy += (centroidY - node.y) * strength;
                            }
                        }
                    });
                }

                force.initialize = function(_) {
                    nodes = _;
                };

                return force;
            }

            // Calculate subtree width for each node (only visible nodes)
            const subtreeWidths = new Map();
            const subtreeHalfWidths = new Map();

            function calculateSubtreeWidth(nodeId, visited = new Set()) {
                if (subtreeWidths.has(nodeId)) {
                    return subtreeWidths.get(nodeId);
                }

                // Prevent infinite recursion in case of cycles
                if (visited.has(nodeId)) {
                    return 160;
                }
                visited.add(nodeId);

                const premises = conclusionToPremises.get(nodeId);

                // Filter out collapsed premises - only consider visible ones
                const visiblePremises = premises
                    ? premises.filter(p => !collapsedNodes.has(p))
                    : [];

                if (visiblePremises.length === 0) {
                    // Leaf node or all premises hidden - just its own width
                    const width = 160; // Node diameter + padding
                    subtreeWidths.set(nodeId, width);
                    subtreeHalfWidths.set(nodeId, width / 2);
                    return width;
                }

                // Non-leaf - sum of visible children subtree widths + spacing
                let totalWidth = 0;
                visiblePremises.forEach(premiseId => {
                    totalWidth += calculateSubtreeWidth(premiseId, visited);
                });

                // Add spacing between sibling subtrees
                totalWidth += (visiblePremises.length - 1) * 100;

                // Node's subtree is at least as wide as its children
                const width = Math.max(160, totalWidth);
                subtreeWidths.set(nodeId, width);
                subtreeHalfWidths.set(nodeId, width / 2);
                return width;
            }

            // Calculate widths only for visible nodes
            visibleClaims.forEach(claim => {
                calculateSubtreeWidth(claim.id);
            });

            // Calculate actual spatial extent (bounding box) of a subtree
            function getSubtreeExtent(nodeId, nodes, visited = new Set()) {
                if (visited.has(nodeId)) {
                    return { minX: Infinity, maxX: -Infinity };
                }
                visited.add(nodeId);

                const node = nodes.find(n => n.id === nodeId);
                if (!node) {
                    return { minX: Infinity, maxX: -Infinity };
                }

                const radius = node.type === 'claim' ? (fullTextMode ? 85 : 70) : 20;
                let minX = node.x - radius;
                let maxX = node.x + radius;

                // Include all visible premises in the extent
                const premises = conclusionToPremises.get(nodeId);
                if (premises) {
                    premises.forEach(premiseId => {
                        if (!collapsedNodes.has(premiseId)) {
                            const extent = getSubtreeExtent(premiseId, nodes, visited);
                            minX = Math.min(minX, extent.minX);
                            maxX = Math.max(maxX, extent.maxX);
                        }
                    });
                }

                return { minX, maxX };
            }

            // Custom force to prevent subtree overlap using actual spatial extents
            function subtreeCollisionForce() {
                let nodes;

                function force(alpha) {
                    // Cache extent calculations to avoid recomputation
                    const extentCache = new Map();

                    function getCachedExtent(nodeId) {
                        if (!extentCache.has(nodeId)) {
                            extentCache.set(nodeId, getSubtreeExtent(nodeId, nodes));
                        }
                        return extentCache.get(nodeId);
                    }

                    // For each implication, ensure sibling subtrees don't overlap
                    hypergraph.implications.forEach(impl => {
                        const conclusionNode = nodes.find(n => n.id === impl.conclusion);
                        if (!conclusionNode) return;

                        // Only consider visible premises (not collapsed)
                        const premiseNodes = impl.premises
                            .filter(id => !collapsedNodes.has(id))
                            .map(id => nodes.find(n => n.id === id))
                            .filter(n => n);

                        if (premiseNodes.length < 2) return;

                        // Sort premises by current x position
                        premiseNodes.sort((a, b) => a.x - b.x);

                        // Check ALL pairs of siblings for overlap (not just adjacent)
                        for (let i = 0; i < premiseNodes.length; i++) {
                            for (let j = i + 1; j < premiseNodes.length; j++) {
                                const node1 = premiseNodes[i];
                                const node2 = premiseNodes[j];

                                // Get actual spatial extent of each subtree
                                const extent1 = getCachedExtent(node1.id);
                                const extent2 = getCachedExtent(node2.id);

                                const minGap = 100; // Minimum spacing between subtrees
                                const currentGap = extent2.minX - extent1.maxX;

                                if (currentGap < minGap) {
                                    // Subtrees are overlapping or too close
                                    const overlap = minGap - currentGap;
                                    const strength = 0.3 * alpha; // Very gentle force

                                    // Push them apart proportional to overlap
                                    node1.vx -= overlap * strength;
                                    node2.vx += overlap * strength;
                                }
                            }
                        }

                        // Center the group of premises under the conclusion
                        if (premiseNodes.length > 0) {
                            const extents = premiseNodes.map(p => getCachedExtent(p.id));
                            const minX = Math.min(...extents.map(e => e.minX));
                            const maxX = Math.max(...extents.map(e => e.maxX));

                            const groupCenterX = (minX + maxX) / 2;
                            const idealCenterX = conclusionNode.x;
                            const offset = idealCenterX - groupCenterX;

                            // Pull the whole group to center under conclusion
                            const strength = 0.1 * alpha;
                            premiseNodes.forEach(p => {
                                p.vx += offset * strength;
                            });
                        }
                    });
                }

                force.initialize = function(_) {
                    nodes = _;
                };

                return force;
            }

            simulation = d3.forceSimulation(allNodes)
                .velocityDecay(0.2) // Strong friction to prevent shaking (default: 0.4, lower = more damping)
                .alphaDecay(0.05) // Faster cooldown (default: 0.0228)
                .force('link', d3.forceLink(links).id(d => d.id).distance(200).strength(0.8))
                .force('charge', d3.forceManyBody().strength(-100))
                .force('x', d3.forceX(d => {
                    // Root conclusions strongly anchored to center
                    if (rootConclusions.includes(d.id)) return width / 2;
                    return width / 2;
                }).strength(d => {
                    // Stronger centering for root conclusions
                    if (d.type === 'claim' && rootConclusions.includes(d.id)) return 0.3;
                    return 0.03;
                }))
                .force('y', d3.forceY(d => d.targetY).strength(0.9))
                .force('collision', d3.forceCollide().radius(d => d.type === 'claim' ? (fullTextMode ? 85 : 70) : 20))
                .force('junction-centroid', junctionCentroidForce())
                .force('subtree-collision', subtreeCollisionForce());

            // Add defs for markers and filters (to svg, not g)
            const defs = svg.append('defs');

            // Arrowhead marker
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 20)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#58a6ff');

            // Glow filter for smooth blending
            const filter = defs.append('filter')
                .attr('id', 'glow')
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');

            filter.append('feGaussianBlur')
                .attr('stdDeviation', '2')
                .attr('result', 'coloredBlur');

            const feMerge = filter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            // Draw links as curved paths
            const link = g.append('g')
                .selectAll('path')
                .data(links)
                .join('path')
                .attr('class', d => `hyperedge ${d.type}`)
                .attr('stroke', d => d.type === 'junction-to-conclusion' ? '#58a6ff' : '#8b949e')
                .attr('stroke-width', d => d.type === 'junction-to-conclusion' ? 3 : 2)
                .attr('opacity', 0.7)
                .attr('fill', 'none')
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .attr('filter', 'url(#glow)')
                .attr('marker-end', d => d.type === 'junction-to-conclusion' ? 'url(#arrowhead)' : null);

            // Draw all nodes
            const node = g.append('g')
                .selectAll('g')
                .data(allNodes)
                .join('g')
                .attr('class', d => d.type === 'claim' ? 'claim-node' : 'junction-node')
                .call(d3.drag()
                    .clickDistance(5) // Must move 5px before it's considered a drag (prevents accidental restarts)
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Render claim nodes
            node.filter(d => d.type === 'claim')
                .append('circle')
                .attr('r', fullTextMode ? 65 : 50)
                .attr('fill', d => getScoreColor(d.score))
                .attr('fill-opacity', 0.2)
                .attr('stroke', d => getScoreColor(d.score))
                .attr('stroke-width', 2)
                .attr('cursor', 'pointer')
                .attr('class', 'claim-circle');

            // Add claim text with wrapping
            node.filter(d => d.type === 'claim')
                .each(function(d) {
                    const text = d3.select(this).append('text')
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#e6edf3')
                        .attr('font-size', fullTextMode ? '10px' : '11px')
                        .attr('font-weight', '500')
                        .attr('pointer-events', 'none')
                        .attr('class', 'claim-text');

                    // Wrap text to fit in circle
                    const words = d.text.split(/\s+/);
                    const maxWidth = fullTextMode ? 110 : 85;
                    const lineHeight = fullTextMode ? 11 : 12;
                    const maxLines = fullTextMode ? 10 : 4;

                    let line = [];
                    let lineNumber = 0;
                    let tspan = text.append('tspan')
                        .attr('x', 0)
                        .attr('dy', 0);

                    for (let i = 0; i < words.length; i++) {
                        line.push(words[i]);
                        tspan.text(line.join(' '));

                        if (tspan.node().getComputedTextLength() > maxWidth) {
                            if (!fullTextMode && lineNumber >= maxLines - 1) {
                                // Last line - truncate with ellipsis in compact mode
                                line.pop();
                                tspan.text(line.join(' ') + '...');
                                break;
                            }
                            line.pop();
                            tspan.text(line.join(' '));
                            line = [words[i]];
                            lineNumber++;
                            tspan = text.append('tspan')
                                .attr('x', 0)
                                .attr('dy', lineHeight)
                                .text(words[i]);
                        }
                    }

                    // Center the text block vertically
                    const totalHeight = (lineNumber + 1) * lineHeight;
                    text.attr('transform', `translate(0, ${-totalHeight / 2 + 5})`);
                });

            // Add expand/collapse indicator for conclusion nodes
            node.filter(d => d.type === 'claim' && isConclusion(d.id))
                .each(function(d) {
                    const g = d3.select(this);
                    const radius = fullTextMode ? 65 : 50;

                    // Small circle for +/- indicator at bottom-right
                    g.append('circle')
                        .attr('cx', radius * 0.6)
                        .attr('cy', radius * 0.6)
                        .attr('r', 12)
                        .attr('fill', '#58a6ff')
                        .attr('stroke', '#e6edf3')
                        .attr('stroke-width', 2)
                        .attr('class', 'expand-indicator');

                    // +/- symbol
                    const isCollapsed = arePremisesCollapsed(d.id);
                    g.append('text')
                        .attr('x', radius * 0.6)
                        .attr('y', radius * 0.6)
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('fill', '#0f1419')
                        .attr('font-size', '14px')
                        .attr('font-weight', '700')
                        .attr('pointer-events', 'none')
                        .attr('class', 'expand-symbol')
                        .text(isCollapsed ? '+' : '−');
                });

            // Render junction nodes (small diamonds/circles)
            node.filter(d => d.type === 'junction')
                .append('circle')
                .attr('r', 8)
                .attr('fill', '#58a6ff')
                .attr('stroke', '#58a6ff')
                .attr('stroke-width', 2)
                .attr('opacity', 0.9);

            node.filter(d => d.type === 'junction')
                .append('text')
                .text('∧')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                .attr('fill', '#0f1419')
                .attr('font-size', '12px')
                .attr('font-weight', '700')
                .attr('pointer-events', 'none');

            // Tooltip on hover (shows ID and full text)
            node.filter(d => d.type === 'claim')
                .append('title')
                .text(d => `${d.id}\n${d.text}\nScore: ${d.score}/10`);

            node.filter(d => d.type === 'junction')
                .append('title')
                .text(d => `AND junction\n${d.implication.id}: ${d.implication.premises.join(' ∧ ')} → ${d.implication.conclusion}`);

            // Click handler for claims
            node.filter(d => d.type === 'claim')
                .on('click', (event, d) => {
                    // If this is a conclusion node, toggle collapse
                    if (isConclusion(d.id)) {
                        toggleCollapse(d.id);
                    } else {
                        // Otherwise, select it (highlight)
                        selectClaim(d.id);
                    }
                });

            // Helper function to create smooth, flowing curves
            function createCurvePath(d) {
                const sourceX = d.source.x;
                const sourceY = d.source.y;
                const targetX = d.target.x;
                const targetY = d.target.y;

                if (d.type === 'premise-to-junction') {
                    // Create smooth S-curve that flows into junction
                    const dx = targetX - sourceX;
                    const dy = targetY - sourceY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Two control points for cubic bezier - creates flowing S-curve
                    const tension = 0.4; // Controls curve tightness

                    // First control point: start the curve from source
                    const cp1X = sourceX + dx * 0.3;
                    const cp1Y = sourceY + dy * 0.3;

                    // Second control point: guide into junction smoothly
                    const cp2X = targetX - dx * 0.2;
                    const cp2Y = targetY - dy * 0.2;

                    // Add subtle perpendicular pull for multiple edges
                    const perpX = -dy / (dist || 1) * 20;
                    const perpY = dx / (dist || 1) * 20;

                    return `M ${sourceX},${sourceY} C ${cp1X + perpX * 0.5},${cp1Y + perpY * 0.5} ${cp2X + perpX * 0.3},${cp2Y + perpY * 0.3} ${targetX},${targetY}`;
                } else {
                    // Smooth curve for junction to conclusion
                    const dx = targetX - sourceX;
                    const dy = targetY - sourceY;

                    // Control points for gentle arc
                    const cp1X = sourceX + dx * 0.3;
                    const cp1Y = sourceY + dy * 0.3 - 15;

                    const cp2X = sourceX + dx * 0.7;
                    const cp2Y = sourceY + dy * 0.7 - 15;

                    return `M ${sourceX},${sourceY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${targetX},${targetY}`;
                }
            }

            // Update positions on simulation tick
            simulation.on('tick', () => {
                link.attr('d', createCurvePath);
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Stop simulation completely when it settles to prevent drift
            simulation.on('end', () => {
                console.log('Simulation settled');
            });

            if (!physicsEnabled) {
                simulation.stop();
            }
        }

        let isDragging = false;

        function dragstarted(event, d) {
            // Mark that we might be dragging
            isDragging = false;
        }

        function dragged(event, d) {
            // Actually dragging - pin node and restart simulation
            if (!isDragging) {
                isDragging = true;
                d.fx = d.x;
                d.fy = d.y;
                if (!event.active) simulation.alphaTarget(0.05).restart();
            }
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            // Only unpin if we actually dragged
            if (isDragging) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
                isDragging = false;
            }
        }

        function resetView() {
            selectedClaim = null;
            document.querySelectorAll('.claim-card').forEach(card => {
                card.classList.remove('selected');
            });

            d3.selectAll('.claim-node')
                .attr('opacity', 1)
                .attr('stroke-width', 2);

            d3.selectAll('.hyperedge')
                .attr('opacity', 0.6);

            if (simulation) {
                simulation.alpha(1).restart();
            }
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            if (physicsEnabled) {
                simulation.restart();
            } else {
                simulation.stop();
            }
        }

        function toggleTextMode() {
            fullTextMode = !fullTextMode;
            const button = document.getElementById('toggle-text');
            button.textContent = fullTextMode ? 'Compact Text' : 'Full Text';

            // Re-render the graph with new text mode
            renderHypergraph();
        }

        function zoomBy(factor) {
            if (!svg || !zoom) return;
            svg.transition()
                .duration(300)
                .call(zoom.scaleBy, factor);
        }

        function resetZoom() {
            if (!svg || !zoom) return;
            svg.transition()
                .duration(500)
                .call(zoom.transform, d3.zoomIdentity);
        }
    </script>
</body>
</html>
