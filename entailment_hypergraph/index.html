<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entailment Hypergraph Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f1419;
            --bg-secondary: #1a1f2e;
            --bg-tertiary: #252b3b;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --border: #30363d;
            --accent: #58a6ff;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --junction-bg: #0f1419;
        }

        :root[data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f6f8fa;
            --bg-tertiary: #eaeef2;
            --text-primary: #24292f;
            --text-secondary: #57606a;
            --border: #d0d7de;
            --accent: #0969da;
            --success: #1a7f37;
            --warning: #9a6700;
            --danger: #cf222e;
            --junction-bg: #ffffff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 2rem;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        select, button {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 0.6rem 1rem;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        button:hover, select:hover {
            border-color: var(--accent);
        }

        button:active {
            transform: translateY(1px);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 2rem;
        }

        .viz-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 1rem;
            position: relative;
            min-height: 600px;
        }

        #graph {
            width: 100%;
            height: 800px;
            border-radius: 6px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
        }

        .panel-title {
            color: var(--accent);
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
        }

        .claim-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .claim-card:hover {
            border-color: var(--accent);
            background: #2d3548;
        }

        .claim-card.selected {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.2);
        }

        .claim-id {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .claim-text {
            font-size: 0.9rem;
            line-height: 1.5;
            margin-bottom: 0.5rem;
        }

        .claim-score {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .score-high { background: rgba(63, 185, 80, 0.2); color: var(--success); }
        .score-medium { background: rgba(210, 153, 34, 0.2); color: var(--warning); }
        .score-low { background: rgba(248, 81, 73, 0.2); color: var(--danger); }

        .implication-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-left: 3px solid var(--accent);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }

        .impl-id {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .impl-formula {
            font-family: 'SF Mono', Monaco, monospace;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .impl-reasoning {
            color: var(--text-secondary);
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .legend {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid;
        }

        .legend-line {
            width: 30px;
            height: 2px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        /* Outline view styles */
        #outline {
            padding: 1rem;
            overflow-y: auto;
            max-height: 800px;
            font-size: 0.9rem;
        }

        .outline-node {
            margin-bottom: 0.5rem;
        }

        .outline-claim {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-left: 3px solid;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .outline-claim:hover {
            background: #2d3548;
            border-left-color: var(--accent);
        }

        .outline-claim.selected {
            border-left-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.2);
        }

        .outline-expand {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--accent);
            cursor: pointer;
            user-select: none;
        }

        .outline-expand:hover {
            color: var(--text-primary);
        }

        .outline-content {
            flex: 1;
            min-width: 0;
        }

        .outline-id {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .outline-text {
            line-height: 1.5;
            margin-bottom: 0.5rem;
        }

        .outline-score {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .outline-children {
            margin-left: 2rem;
            margin-top: 0.5rem;
            border-left: 2px solid var(--border);
            padding-left: 1rem;
        }

        .outline-children.collapsed {
            display: none;
        }

        .outline-implication {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            font-family: 'SF Mono', Monaco, monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Entailment Hypergraph Visualizer</h1>
            <div class="subtitle">Atomic claims as nodes, implications as hyperedges</div>
        </header>

        <div class="controls">
            <select id="example-select">
                <option value="">Loading...</option>
            </select>
            <button id="toggle-theme">ðŸŒ™ Dark Mode</button>
            <button id="toggle-view-mode">View: Graph</button>
            <button id="reset-view">Reset View</button>
            <button id="toggle-text">Compact Text</button>
            <button id="zoom-in">Zoom In</button>
            <button id="zoom-out">Zoom Out</button>
            <button id="zoom-reset">Reset Zoom</button>
        </div>

        <div class="main-content">
            <div class="viz-container">
                <svg id="graph"></svg>
                <div id="outline" style="display: none;"></div>
            </div>

            <div class="sidebar">
                <div class="panel" id="details-panel" style="display: none;">
                    <div class="panel-title">Selected Item</div>
                    <div id="details-content"></div>
                </div>

                <div class="panel">
                    <div class="panel-title">Claims (Nodes)</div>
                    <div id="claims-list"></div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-circle" style="border-color: #3fb950; background: rgba(63, 185, 80, 0.2);"></div>
                            <span>High (7.5-10)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-circle" style="border-color: #d29922; background: rgba(210, 153, 34, 0.2);"></div>
                            <span>Medium (5-7.5)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-circle" style="border-color: #f85149; background: rgba(248, 81, 73, 0.2);"></div>
                            <span>Low (0-5)</span>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Implications (Hyperedges)</div>
                    <div id="implications-list"></div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-circle" style="width: 12px; height: 12px; border-color: #58a6ff; background: #58a6ff;"></div>
                            <span>AND junction (âˆ§)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-circle" style="width: 12px; height: 12px; border-color: #d29922; background: #d29922;"></div>
                            <span>OR junction (âˆ¨)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: #8b949e;"></div>
                            <span>Premise edges</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: #58a6ff; height: 3px;"></div>
                            <span>Conclusion edge</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let hypergraph = null;
        let selectedItem = null; // { type: 'claim' | 'implication', id: string }
        let fullTextMode = true;
        let zoom = null;
        let svg = null;
        let g = null;

        // View mode: 'graph' or 'outline'
        let viewMode = 'graph';

        // Collapse state for graph view
        let collapsedNodes = new Set();
        let conclusionToPremises = new Map();

        // Collapse state for outline view (separate from graph)
        let outlineCollapsedNodes = new Set();

        // Node positions (persistent across renders)
        let nodePositions = new Map();

        // WebSocket connection for real-time updates
        let ws = null;
        let wsReconnectTimer = null;
        let useWebSocket = true; // Toggle for fallback to polling

        // Auto-reload interval (fallback when WebSocket unavailable)
        let autoReloadInterval = null;
        let currentGraphPath = null;

        // Initialize theme from localStorage or default to dark
        const savedTheme = localStorage.getItem('theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
        updateThemeButton();

        function updateThemeButton() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const button = document.getElementById('toggle-theme');
            if (currentTheme === 'light') {
                button.textContent = 'â˜€ï¸ Light Mode';
            } else {
                button.textContent = 'ðŸŒ™ Dark Mode';
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeButton();

            // Re-render graph to update colors
            if (viewMode === 'graph' && hypergraph) {
                renderHypergraph();
            }
        }

        // WebSocket connection management
        function connectWebSocket() {
            if (!useWebSocket) return;

            // Determine WebSocket URL based on current location
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            console.log('[WebSocket] Connecting to', wsUrl);

            try {
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('[WebSocket] âœ“ Connected');
                    // Stop polling if it was running
                    stopAutoReload();

                    // Send ping every 30 seconds to keep connection alive
                    if (ws.pingInterval) clearInterval(ws.pingInterval);
                    ws.pingInterval = setInterval(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send('ping');
                        }
                    }, 30000);
                };

                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleWebSocketUpdate(message);
                    } catch (e) {
                        console.error('[WebSocket] Error parsing message:', e);
                    }
                };

                ws.onerror = (error) => {
                    console.error('[WebSocket] Error:', error);
                };

                ws.onclose = () => {
                    console.log('[WebSocket] Disconnected');
                    if (ws.pingInterval) clearInterval(ws.pingInterval);

                    // Attempt reconnection after 2 seconds
                    if (wsReconnectTimer) clearTimeout(wsReconnectTimer);
                    wsReconnectTimer = setTimeout(() => {
                        console.log('[WebSocket] Attempting to reconnect...');
                        connectWebSocket();
                    }, 2000);
                };
            } catch (error) {
                console.error('[WebSocket] Connection failed:', error);
                // Fall back to polling
                console.log('[WebSocket] Falling back to polling mode');
                useWebSocket = false;
                if (currentGraphPath) {
                    startAutoReload();
                }
            }
        }

        function handleWebSocketUpdate(message) {
            console.log('[WebSocket] Received update:', message.type);

            if (message.type === 'hypergraph_update') {
                // Check if this update is for the currently displayed graph
                const messagePath = message.path.replace(/\\/g, '/');
                const currentPath = currentGraphPath ? currentGraphPath.replace(/^\//, '') : '';

                if (messagePath.includes(currentPath) || currentPath.includes(messagePath.split('/').pop())) {
                    console.log('[WebSocket] Update matches current graph, reloading...');

                    // Save current transform for smooth transition
                    let savedTransform = null;
                    if (svg) {
                        savedTransform = d3.zoomTransform(svg.node());
                    }

                    // Update hypergraph data
                    hypergraph = message.data;

                    // Rebuild structures and re-render
                    buildImplicationMap();
                    renderCurrentView();
                    renderSidebar();

                    // Restore zoom/pan
                    if (savedTransform && svg && zoom) {
                        svg.call(zoom.transform, savedTransform);
                    }
                }
            }
        }

        // Check URL parameter for graph file
        const urlParams = new URLSearchParams(window.location.search);
        const graphParam = urlParams.get('graph');

        // Load catalog and populate dropdown
        async function loadCatalog() {
            try {
                const response = await fetch('/entailment_hypergraph/hypergraph_catalog.json');
                const catalog = await response.json();

                const select = document.getElementById('example-select');
                select.innerHTML = '';

                // Add examples section
                if (catalog.examples && catalog.examples.length > 0) {
                    const exampleGroup = document.createElement('optgroup');
                    exampleGroup.label = 'Examples';
                    catalog.examples.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item.path;
                        option.textContent = item.name;
                        exampleGroup.appendChild(option);
                    });
                    select.appendChild(exampleGroup);
                }

                // Add approaches section
                if (catalog.approaches && catalog.approaches.length > 0) {
                    const approachGroup = document.createElement('optgroup');
                    approachGroup.label = 'Your Approaches';
                    catalog.approaches.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item.path;
                        option.textContent = item.name;
                        approachGroup.appendChild(option);
                    });
                    select.appendChild(approachGroup);
                }

                // Set selected value if we have a current path
                if (currentGraphPath) {
                    select.value = currentGraphPath;
                }
            } catch (error) {
                console.error('Failed to load catalog:', error);
                // Fallback to hardcoded examples
                const select = document.getElementById('example-select');
                select.innerHTML = `
                    <option value="/entailment_hypergraph/water_boiling_example.json">Water Boiling (Simple)</option>
                    <option value="/entailment_hypergraph/steam_engine_example.json">Steam Engine Feasibility (Complex)</option>
                    <option value="/entailment_hypergraph/ultrasound_eeg_enhancement.json">Ultrasound EEG Enhancement (Real Project)</option>
                `;
            }
        }

        // Initialize WebSocket connection
        connectWebSocket();

        // Load initial example (from URL param or default)
        if (graphParam) {
            currentGraphPath = '/' + graphParam;
            loadCatalog().then(() => loadExample(currentGraphPath));
            // Only start auto-reload if WebSocket fails
            if (!useWebSocket) {
                startAutoReload();
            }
        } else {
            currentGraphPath = '/entailment_hypergraph/water_boiling_example.json';
            loadCatalog().then(() => loadExample(currentGraphPath));
        }

        // Auto-reload function
        function startAutoReload() {
            if (autoReloadInterval) clearInterval(autoReloadInterval);
            autoReloadInterval = setInterval(() => {
                loadExample(currentGraphPath, true); // silent reload
            }, 1000); // 1 second - fast polling for responsive updates
        }

        function stopAutoReload() {
            if (autoReloadInterval) {
                clearInterval(autoReloadInterval);
                autoReloadInterval = null;
            }
        }

        // Event listeners
        document.getElementById('example-select').addEventListener('change', (e) => {
            stopAutoReload(); // Stop auto-reload when manually switching examples
            currentGraphPath = e.target.value;
            loadExample(e.target.value);
        });

        document.getElementById('toggle-theme').addEventListener('click', toggleTheme);
        document.getElementById('toggle-view-mode').addEventListener('click', toggleViewMode);
        document.getElementById('reset-view').addEventListener('click', resetView);
        document.getElementById('toggle-text').addEventListener('click', toggleTextMode);
        document.getElementById('zoom-in').addEventListener('click', () => zoomBy(1.3));
        document.getElementById('zoom-out').addEventListener('click', () => zoomBy(0.7));
        document.getElementById('zoom-reset').addEventListener('click', resetZoom);

        async function loadExample(path, isAutoReload = false) {
            try {
                // Save current view state if auto-reloading
                let savedTransform = null;
                if (isAutoReload && svg) {
                    const currentTransform = d3.zoomTransform(svg.node());
                    savedTransform = currentTransform;
                }

                // Add cache-busting timestamp to ensure fresh data
                const cacheBuster = `?t=${Date.now()}`;
                const response = await fetch(path + cacheBuster);
                hypergraph = await response.json();

                // Only clear state on manual example changes, not auto-reload
                if (!isAutoReload) {
                    collapsedNodes.clear();
                    outlineCollapsedNodes.clear();
                    nodePositions.clear();
                } else {
                    // On auto-reload, clean up stale positions for deleted nodes
                    const currentNodeIds = new Set(hypergraph.claims.map(c => c.id));
                    const currentJunctionIds = new Set(hypergraph.implications.map(i => `junction_${i.id}`));

                    // Remove positions for nodes that no longer exist
                    for (const nodeId of nodePositions.keys()) {
                        if (!currentNodeIds.has(nodeId) && !currentJunctionIds.has(nodeId)) {
                            nodePositions.delete(nodeId);
                        }
                    }

                    // Remove collapsed state for deleted nodes
                    for (const nodeId of collapsedNodes.keys()) {
                        if (!currentNodeIds.has(nodeId)) {
                            collapsedNodes.delete(nodeId);
                        }
                    }

                    for (const nodeId of outlineCollapsedNodes.keys()) {
                        if (!currentNodeIds.has(nodeId)) {
                            outlineCollapsedNodes.delete(nodeId);
                        }
                    }
                }

                buildImplicationMap();
                renderCurrentView();
                renderSidebar();

                // Restore view state after rendering
                if (isAutoReload && savedTransform && svg) {
                    svg.call(zoom.transform, savedTransform);
                }
            } catch (error) {
                console.error('Error loading example:', error);
            }
        }

        function toggleViewMode() {
            viewMode = viewMode === 'graph' ? 'outline' : 'graph';
            const button = document.getElementById('toggle-view-mode');
            button.textContent = viewMode === 'graph' ? 'View: Graph' : 'View: Outline';

            // Clear selection when switching views
            selectedItem = null;
            document.querySelectorAll('.claim-card').forEach(card => {
                card.classList.remove('selected');
            });
            renderDetailsPanel();

            renderCurrentView();
        }

        function renderCurrentView() {
            const graphEl = document.getElementById('graph');
            const outlineEl = document.getElementById('outline');

            if (viewMode === 'graph') {
                graphEl.style.display = 'block';
                outlineEl.style.display = 'none';
                renderHypergraph();
            } else {
                graphEl.style.display = 'none';
                outlineEl.style.display = 'block';
                renderOutline();
            }
        }

        function buildImplicationMap() {
            conclusionToPremises.clear();
            hypergraph.implications.forEach(impl => {
                conclusionToPremises.set(impl.conclusion, impl.premises);
            });
        }

        function isConclusion(nodeId) {
            return conclusionToPremises.has(nodeId);
        }

        function arePremisesCollapsed(conclusionId) {
            const premises = conclusionToPremises.get(conclusionId);
            if (!premises || premises.length === 0) return false;
            return premises.some(p => collapsedNodes.has(p));
        }

        async function toggleCollapse(conclusionId) {
            const premises = conclusionToPremises.get(conclusionId);
            if (!premises) return;

            const currentlyCollapsed = arePremisesCollapsed(conclusionId);

            if (currentlyCollapsed) {
                // EXPAND: Show children sequentially
                await expandWithAnimation(conclusionId, premises);
            } else {
                // COLLAPSE: Hide children sequentially (reverse order)
                await collapseWithAnimation(conclusionId, premises);
            }

            // Update indicators after animation
            updateExpandIndicators();
        }

        async function expandWithAnimation(conclusionId, premises) {
            // Get parent position
            const parentNode = d3.selectAll('.claim-node').filter(d => d.id === conclusionId);
            const parentData = parentNode.datum();
            const parentX = parentData.x;
            const parentY = parentData.y;

            // Get junction for this implication
            const impl = hypergraph.implications.find(i => i.conclusion === conclusionId);
            const junctionId = impl ? `junction_${impl.id}` : null;

            // Recalculate layout to get target positions
            const width = document.getElementById('graph').clientWidth;
            const height = 800;

            // Temporarily mark as expanded to calculate layout
            premises.forEach(p => collapsedNodes.delete(p));
            const visibleClaims = hypergraph.claims
                .map(c => ({...c, type: 'claim'}))
                .filter(c => !collapsedNodes.has(c.id));
            const { positions } = calculateTreeLayout(visibleClaims, width, height);

            // Update ALL node positions from new layout
            updateAllNodePositions(positions);

            // First: Animate all other nodes to new positions to make space
            await animateLayoutChange(positions);

            // Then: Expand junction from parent with edges growing
            if (junctionId) {
                const junctionTarget = positions.get(junctionId);
                const junctionNode = d3.selectAll('.junction-node').filter(d => d.id === junctionId);

                // Animate junction growing from parent position
                junctionNode
                    .style('display', null)
                    .each(function(d) {
                        // Temporarily set position to parent for animation start
                        d._animX = parentX;
                        d._animY = parentY;

                        // Show edges connected to this junction
                        d3.selectAll('.hyperedge')
                            .filter(edge => edge.target.id === junctionId || edge.source.id === junctionId)
                            .each(function(edge) {
                                // Check if the other end of the edge is visible
                                const otherNodeId = edge.source.id === junctionId ? edge.target.id : edge.source.id;

                                // Don't show edges to premises that will be expanded later
                                const isPremiseToExpand = premises.includes(otherNodeId);
                                if (isPremiseToExpand) {
                                    return; // Skip this edge, it will be shown when the premise expands
                                }

                                const otherNodeVisible = !collapsedNodes.has(otherNodeId);

                                if (otherNodeVisible) {
                                    // Show edge starting at zero length from the visible end
                                    const visibleX = edge.source.id === junctionId ? (edge.target.x || parentX) : (edge.source.x || parentX);
                                    const visibleY = edge.source.id === junctionId ? (edge.target.y || parentY) : (edge.source.y || parentY);
                                    d3.select(this)
                                        .attr('d', `M ${visibleX},${visibleY} L ${visibleX},${visibleY}`)
                                        .style('display', null);
                                }
                            });
                    })
                    .attr('transform', `translate(${parentX},${parentY}) scale(0)`)
                    .transition()
                    .duration(300)
                    .ease(d3.easeCubicOut)
                    .attr('transform', `translate(${junctionTarget.x},${junctionTarget.y}) scale(1)`)
                    .tween('position', function(d) {
                        const interpolateX = d3.interpolate(parentX, junctionTarget.x);
                        const interpolateY = d3.interpolate(parentY, junctionTarget.y);
                        return function(t) {
                            d._animX = interpolateX(t);
                            d._animY = interpolateY(t);
                            // Animate edges connected to this junction
                            animateEdgesForNode(d);
                        };
                    })
                    .on('end', function(d) {
                        d.x = junctionTarget.x;
                        d.y = junctionTarget.y;
                        delete d._animX;
                        delete d._animY;
                    });

                await new Promise(resolve => setTimeout(resolve, 300));
            }

            // Step 2: Expand premises sequentially with edges growing
            const expandFromX = positions.get(junctionId)?.x || parentX;
            const expandFromY = positions.get(junctionId)?.y || parentY;

            for (let i = 0; i < premises.length; i++) {
                const premiseId = premises[i];
                const premiseTarget = positions.get(premiseId);
                const premiseNode = d3.selectAll('.claim-node').filter(d => d.id === premiseId);

                // Animate node growing from junction/parent position
                premiseNode
                    .style('display', null)
                    .each(function(d) {
                        d._animX = expandFromX;
                        d._animY = expandFromY;

                        // Show edges connected to this premise
                        d3.selectAll('.hyperedge')
                            .filter(edge => edge.target.id === premiseId || edge.source.id === premiseId)
                            .each(function(edge) {
                                // Check if the other end of the edge is visible
                                const otherNodeId = edge.source.id === premiseId ? edge.target.id : edge.source.id;
                                const otherNodeVisible = !collapsedNodes.has(otherNodeId);

                                if (otherNodeVisible) {
                                    // Show edge starting at zero length from the visible end
                                    let visibleX, visibleY;

                                    if (edge.source.id === premiseId) {
                                        // This premise is the source, other end (target) is visible
                                        visibleX = edge.target._animX !== undefined ? edge.target._animX : (edge.target.x || expandFromX);
                                        visibleY = edge.target._animY !== undefined ? edge.target._animY : (edge.target.y || expandFromY);
                                    } else {
                                        // This premise is the target, other end (source) is visible
                                        visibleX = edge.source._animX !== undefined ? edge.source._animX : (edge.source.x || expandFromX);
                                        visibleY = edge.source._animY !== undefined ? edge.source._animY : (edge.source.y || expandFromY);
                                    }

                                    d3.select(this)
                                        .attr('d', `M ${visibleX},${visibleY} L ${visibleX},${visibleY}`)
                                        .style('display', null);
                                }
                            });
                    })
                    .attr('transform', `translate(${expandFromX},${expandFromY}) scale(0)`)
                    .transition()
                    .duration(400)
                    .ease(d3.easeCubicOut)
                    .attr('transform', `translate(${premiseTarget.x},${premiseTarget.y}) scale(1)`)
                    .tween('position', function(d) {
                        const interpolateX = d3.interpolate(expandFromX, premiseTarget.x);
                        const interpolateY = d3.interpolate(expandFromY, premiseTarget.y);
                        return function(t) {
                            d._animX = interpolateX(t);
                            d._animY = interpolateY(t);
                            // Animate edges connected to this node
                            animateEdgesForNode(d);
                        };
                    })
                    .on('end', function(d) {
                        d.x = premiseTarget.x;
                        d.y = premiseTarget.y;
                        delete d._animX;
                        delete d._animY;
                    });

                await new Promise(resolve => setTimeout(resolve, 150));
            }
        }

        async function collapseWithAnimation(conclusionId, premises) {
            // Get parent position
            const parentNode = d3.selectAll('.claim-node').filter(d => d.id === conclusionId);
            const parentData = parentNode.datum();
            const parentX = parentData.x;
            const parentY = parentData.y;

            // Get junction for this implication
            const impl = hypergraph.implications.find(i => i.conclusion === conclusionId);
            const junctionId = impl ? `junction_${impl.id}` : null;

            // Get junction position if it exists
            const junctionNode = junctionId ? d3.selectAll('.junction-node').filter(d => d.id === junctionId) : null;
            const junctionData = junctionNode ? junctionNode.datum() : null;
            const collapseToX = junctionData?.x || parentX;
            const collapseToY = junctionData?.y || parentY;

            // Step 1: Collapse premises in reverse order (deepest first)
            const premisesReversed = [...premises].reverse();

            for (let i = 0; i < premisesReversed.length; i++) {
                const premiseId = premisesReversed[i];

                // If this premise is also a conclusion, collapse it recursively first
                if (isConclusion(premiseId)) {
                    const subPremises = conclusionToPremises.get(premiseId);
                    if (subPremises && !arePremisesCollapsed(premiseId)) {
                        await collapseWithAnimation(premiseId, subPremises);
                    }
                }

                const premiseNode = d3.selectAll('.claim-node').filter(d => d.id === premiseId);

                // Shrink node back to junction position with edges retracting
                await premiseNode
                    .each(function(d) {
                        d._animX = d.x;
                        d._animY = d.y;
                    })
                    .transition()
                    .duration(300)
                    .ease(d3.easeCubicIn)
                    .attr('transform', `translate(${collapseToX},${collapseToY}) scale(0)`)
                    .tween('position', function(d) {
                        const interpolateX = d3.interpolate(d.x, collapseToX);
                        const interpolateY = d3.interpolate(d.y, collapseToY);
                        return function(t) {
                            d._animX = interpolateX(t);
                            d._animY = interpolateY(t);
                            // Animate edges retracting with this node
                            animateEdgesForNode(d);
                        };
                    })
                    .on('end', function(d) {
                        delete d._animX;
                        delete d._animY;
                    })
                    .end();

                premiseNode.style('display', 'none');
                collapsedNodes.add(premiseId);

                // Hide edges connected to this premise
                d3.selectAll('.hyperedge')
                    .filter(d => d.source.id === premiseId || d.target.id === premiseId)
                    .style('display', 'none');

                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Step 2: Collapse junction back to parent with edges retracting
            if (junctionId && junctionNode) {
                const junctionData = junctionNode.datum();

                await junctionNode
                    .each(function(d) {
                        d._animX = d.x;
                        d._animY = d.y;
                    })
                    .transition()
                    .duration(300)
                    .ease(d3.easeCubicIn)
                    .attr('transform', `translate(${parentX},${parentY}) scale(0)`)
                    .tween('position', function(d) {
                        const interpolateX = d3.interpolate(d.x, parentX);
                        const interpolateY = d3.interpolate(d.y, parentY);
                        return function(t) {
                            d._animX = interpolateX(t);
                            d._animY = interpolateY(t);
                            // Animate edges retracting with this junction
                            animateEdgesForNode(d);
                        };
                    })
                    .on('end', function(d) {
                        delete d._animX;
                        delete d._animY;
                    })
                    .end();

                junctionNode.style('display', 'none');

                // Hide edges connected to this junction
                d3.selectAll('.hyperedge')
                    .filter(d => d.source.id === junctionId || d.target.id === junctionId)
                    .style('display', 'none');
            }

            // Step 3: Recalculate layout for remaining nodes
            const width = document.getElementById('graph').clientWidth;
            const height = 800;
            const visibleClaims = hypergraph.claims
                .map(c => ({...c, type: 'claim'}))
                .filter(c => !collapsedNodes.has(c.id));
            const { positions } = calculateTreeLayout(visibleClaims, width, height);

            // Update positions and animate
            updateAllNodePositions(positions);
            await animateLayoutChange(positions);
        }

        function animateEdgesForNode(node) {
            // Update edge paths for edges connected to this node in real-time
            // Use _animX/_animY if available (during animation), otherwise use x/y
            const nodeX = node._animX !== undefined ? node._animX : node.x;
            const nodeY = node._animY !== undefined ? node._animY : node.y;

            // Update all edges where this node is source or target
            d3.selectAll('.hyperedge').each(function(d) {
                let updated = false;

                // Check if this edge connects to our animating node
                if (d.source.id === node.id) {
                    updated = true;
                } else if (d.target.id === node.id) {
                    updated = true;
                }

                if (updated) {
                    // Get current positions (use anim positions if available)
                    const sourceX = d.source._animX !== undefined ? d.source._animX : d.source.x;
                    const sourceY = d.source._animY !== undefined ? d.source._animY : d.source.y;
                    const targetX = d.target._animX !== undefined ? d.target._animX : d.target.x;
                    const targetY = d.target._animY !== undefined ? d.target._animY : d.target.y;

                    const dx = targetX - sourceX;
                    const dy = targetY - sourceY;

                    // Calculate path
                    let pathD;
                    if (d.type === 'premise-to-junction') {
                        const cp1X = sourceX + dx * 0.3;
                        const cp1Y = sourceY + dy * 0.3;
                        const cp2X = targetX - dx * 0.2;
                        const cp2Y = targetY - dy * 0.2;
                        pathD = `M ${sourceX},${sourceY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${targetX},${targetY}`;
                    } else {
                        const cp1X = sourceX + dx * 0.3;
                        const cp1Y = sourceY + dy * 0.3 - 15;
                        const cp2X = sourceX + dx * 0.7;
                        const cp2Y = sourceY + dy * 0.7 - 15;
                        pathD = `M ${sourceX},${sourceY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${targetX},${targetY}`;
                    }

                    // Update path immediately (no transition, part of node's animation)
                    d3.select(this).attr('d', pathD);
                }
            });
        }

        function updateAllNodePositions(positions) {
            // Update all node data objects with new positions
            d3.selectAll('.claim-node').each(function(d) {
                const newPos = positions.get(d.id);
                if (newPos) {
                    d.x = newPos.x;
                    d.y = newPos.y;
                }
            });

            d3.selectAll('.junction-node').each(function(d) {
                const newPos = positions.get(d.id);
                if (newPos) {
                    d.x = newPos.x;
                    d.y = newPos.y;
                }
            });

            // Update edge source/target references
            d3.selectAll('.hyperedge').each(function(d) {
                // Source and target are node objects, their x/y are already updated above
                // Just need to make sure the reference is still valid
            });
        }

        async function animateLayoutChange(positions) {
            // Animate all visible nodes to their new positions
            d3.selectAll('.claim-node')
                .filter(d => !collapsedNodes.has(d.id))
                .transition()
                .duration(600)
                .ease(d3.easeCubicInOut)
                .attr('transform', d => `translate(${d.x},${d.y}) scale(1)`);

            d3.selectAll('.junction-node')
                .filter(d => {
                    // Check if junction is visible (its conclusion and all premises are visible)
                    const impl = d.implication;
                    if (collapsedNodes.has(impl.conclusion)) return false;
                    if (impl.premises.some(p => collapsedNodes.has(p))) return false;
                    return true;
                })
                .transition()
                .duration(600)
                .ease(d3.easeCubicInOut)
                .attr('transform', d => `translate(${d.x},${d.y}) scale(1)`);

            // Animate all visible edges
            await new Promise(resolve => setTimeout(resolve, 100));
            await animateEdges();
        }

        async function animateEdges() {
            // Animate edge paths to follow updated node positions
            d3.selectAll('.hyperedge')
                .transition()
                .duration(400)
                .ease(d3.easeCubicInOut)
                .attr('d', function(d) {
                    const sourceX = d.source.x;
                    const sourceY = d.source.y;
                    const targetX = d.target.x;
                    const targetY = d.target.y;
                    const dx = targetX - sourceX;
                    const dy = targetY - sourceY;

                    if (d.type === 'premise-to-junction') {
                        const cp1X = sourceX + dx * 0.3;
                        const cp1Y = sourceY + dy * 0.3;
                        const cp2X = targetX - dx * 0.2;
                        const cp2Y = targetY - dy * 0.2;
                        return `M ${sourceX},${sourceY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${targetX},${targetY}`;
                    } else {
                        const cp1X = sourceX + dx * 0.3;
                        const cp1Y = sourceY + dy * 0.3 - 15;
                        const cp2X = sourceX + dx * 0.7;
                        const cp2Y = sourceY + dy * 0.7 - 15;
                        return `M ${sourceX},${sourceY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${targetX},${targetY}`;
                    }
                });

            await new Promise(resolve => setTimeout(resolve, 400));
        }

        function updateNodeVisibility() {
            // Hide/show claim nodes based on collapsed state
            d3.selectAll('.claim-node')
                .style('display', d => collapsedNodes.has(d.id) ? 'none' : null);

            // Hide/show junction nodes based on their conclusion and premises
            d3.selectAll('.junction-node')
                .style('display', d => {
                    const impl = d.implication;
                    if (collapsedNodes.has(impl.conclusion)) return 'none';
                    if (impl.premises.some(p => collapsedNodes.has(p))) return 'none';
                    return null;
                });

            // Hide/show edges based on whether source or target is collapsed
            d3.selectAll('.hyperedge')
                .style('display', function(d) {
                    // Hide edge if either source or target is collapsed
                    if (collapsedNodes.has(d.source.id)) return 'none';
                    if (collapsedNodes.has(d.target.id)) return 'none';
                    return null;
                });
        }

        function updateExpandIndicators() {
            // Update +/âˆ’ symbols
            d3.selectAll('.claim-node').each(function(d) {
                if (isConclusion(d.id)) {
                    const isCollapsed = arePremisesCollapsed(d.id);
                    d3.select(this).select('.expand-symbol')
                        .text(isCollapsed ? '+' : 'âˆ’');
                }
            });
        }

        function collapseRecursive(nodeId) {
            const premises = conclusionToPremises.get(nodeId);
            if (!premises) return;

            premises.forEach(premiseId => {
                collapsedNodes.add(premiseId);
                if (isConclusion(premiseId)) {
                    collapseRecursive(premiseId);
                }
            });
        }

        function getScoreColor(score) {
            if (score >= 7.5) return '#3fb950';
            if (score >= 5) return '#d29922';
            return '#f85149';
        }

        function getScoreClass(score) {
            if (score >= 7.5) return 'score-high';
            if (score >= 5) return 'score-medium';
            return 'score-low';
        }

        function renderSidebar() {
            const claimsList = document.getElementById('claims-list');
            claimsList.innerHTML = hypergraph.claims.map(claim => `
                <div class="claim-card" data-claim-id="${claim.id}">
                    <div class="claim-id">${claim.id}</div>
                    <div class="claim-text">${claim.text}</div>
                    <span class="claim-score ${getScoreClass(claim.score)}">${claim.score}/10</span>
                </div>
            `).join('');

            document.querySelectorAll('.claim-card').forEach(card => {
                card.addEventListener('click', () => {
                    selectClaim(card.dataset.claimId);
                });
            });

            const implList = document.getElementById('implications-list');
            implList.innerHTML = hypergraph.implications.map(impl => {
                const premiseIds = impl.premises.join(', ');
                const formula = `(${premiseIds}) â†’ ${impl.conclusion}`;
                return `
                    <div class="implication-item">
                        <div class="impl-id">${impl.id}</div>
                        <div class="impl-formula">${formula}</div>
                        <div class="impl-reasoning">${impl.reasoning}</div>
                    </div>
                `;
            }).join('');
        }

        function selectClaim(claimId) {
            selectedItem = { type: 'claim', id: claimId };

            document.querySelectorAll('.claim-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.claimId === claimId);
            });

            highlightClaim(claimId);
            renderDetailsPanel();
        }

        function selectImplication(implId) {
            selectedItem = { type: 'implication', id: implId };

            // Clear claim selection in sidebar
            document.querySelectorAll('.claim-card').forEach(card => {
                card.classList.remove('selected');
            });

            highlightImplication(implId);
            renderDetailsPanel();
        }

        function highlightClaim(claimId) {
            d3.selectAll('.claim-node')
                .attr('opacity', d => d.id === claimId ? 1 : 0.3)
                .attr('stroke-width', d => d.id === claimId ? 4 : 2);

            d3.selectAll('.hyperedge')
                .attr('opacity', d => {
                    return d.premises.includes(claimId) || d.conclusion === claimId ? 1 : 0.2;
                })
                .attr('stroke-width', d => {
                    const baseWidth = d.type === 'junction-to-conclusion' ? 3 : 2;
                    return baseWidth;
                });
        }

        function highlightImplication(implId) {
            const impl = hypergraph.implications.find(i => i.id === implId);
            if (!impl) return;

            d3.selectAll('.claim-node')
                .attr('opacity', d => {
                    return impl.premises.includes(d.id) || d.id === impl.conclusion ? 1 : 0.3;
                })
                .attr('stroke-width', 2);

            d3.selectAll('.hyperedge')
                .attr('opacity', d => d.implId === implId ? 1 : 0.2)
                .attr('stroke-width', d => {
                    if (d.implId === implId) {
                        return d.type === 'junction-to-conclusion' ? 5 : 4;
                    }
                    const baseWidth = d.type === 'junction-to-conclusion' ? 3 : 2;
                    const dx = Math.abs(d.target.x - d.source.x);
                    const isVertical = dx < 5;
                    return isVertical ? baseWidth + 1 : baseWidth;
                });
        }

        function renderDetailsPanel() {
            const panel = document.getElementById('details-panel');
            const content = document.getElementById('details-content');

            if (!selectedItem) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';

            if (selectedItem.type === 'claim') {
                const claim = hypergraph.claims.find(c => c.id === selectedItem.id);
                if (!claim) return;

                content.innerHTML = `
                    <div style="margin-bottom: 1rem;">
                        <div style="font-family: 'SF Mono', Monaco, monospace; font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                            ${claim.id}
                        </div>
                        <div style="font-size: 0.95rem; line-height: 1.5; margin-bottom: 0.75rem;">
                            ${claim.text}
                        </div>
                        <div style="margin-bottom: 0.75rem;">
                            <span style="display: inline-block; padding: 0.2rem 0.6rem; border-radius: 12px; font-size: 0.75rem; font-weight: 600;"
                                  class="${getScoreClass(claim.score)}">
                                Score: ${claim.score}/10
                            </span>
                        </div>
                        ${claim.tags && claim.tags.length > 0 ? `
                            <div style="margin-top: 0.5rem;">
                                ${claim.tags.map(tag => `
                                    <span style="display: inline-block; padding: 0.2rem 0.5rem; background: rgba(248, 81, 73, 0.2); color: var(--danger); border-radius: 4px; font-size: 0.7rem; margin-right: 0.5rem; font-weight: 600;">
                                        ${tag}
                                    </span>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                    ${claim.reasoning ? `
                        <div style="border-top: 1px solid var(--border); padding-top: 1rem; margin-bottom: 1rem;">
                            <div style="font-weight: 600; margin-bottom: 0.5rem; color: var(--accent);">Reasoning</div>
                            <div style="font-size: 0.9rem; line-height: 1.6; color: var(--text-secondary);">
                                ${claim.reasoning}
                            </div>
                        </div>
                    ` : ''}
                    ${claim.evidence ? `
                        <div style="border-top: 1px solid var(--border); padding-top: 1rem; margin-bottom: 1rem;">
                            <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--accent);">Evidence</div>
                            ${claim.evidence.map(e => {
                                let evidenceContent = '';

                                if (e.type === 'literature') {
                                    evidenceContent = `
                                        <div style="font-size: 0.85rem; margin-bottom: 0.5rem; color: var(--text-secondary); font-family: 'SF Mono', Monaco, monospace;">
                                            Source: ${e.source}
                                        </div>
                                        <div style="font-size: 0.85rem; line-height: 1.5; white-space: pre-wrap;">
                                            ${e.reference_text || 'No reference text'}
                                        </div>
                                    `;
                                } else if (e.type === 'simulation') {
                                    evidenceContent = `
                                        <div style="font-size: 0.85rem; margin-bottom: 0.5rem; color: var(--text-secondary); font-family: 'SF Mono', Monaco, monospace;">
                                            ${e.source}:${e.lines || '?'}
                                        </div>
                                        <pre style="font-family: 'SF Mono', Monaco, monospace; font-size: 0.8rem; line-height: 1.4; background: var(--bg-primary); padding: 0.5rem; border-radius: 4px; overflow-x: auto; white-space: pre-wrap;">${e.code || 'No code'}</pre>
                                    `;
                                } else if (e.type === 'calculation') {
                                    evidenceContent = `
                                        <div style="margin-bottom: 0.75rem;">
                                            <div style="font-weight: 600; font-size: 0.75rem; margin-bottom: 0.5rem; color: var(--text-secondary);">EQUATIONS</div>
                                            <div style="font-family: 'SF Mono', Monaco, monospace; font-size: 0.85rem; line-height: 1.5; white-space: pre-wrap;">
                                                ${e.equations || 'No equations'}
                                            </div>
                                        </div>
                                        <div>
                                            <div style="font-weight: 600; font-size: 0.75rem; margin-bottom: 0.5rem; color: var(--text-secondary);">PROGRAM</div>
                                            <pre style="font-family: 'SF Mono', Monaco, monospace; font-size: 0.8rem; line-height: 1.4; background: var(--bg-primary); padding: 0.5rem; border-radius: 4px; overflow-x: auto;">${e.program || 'No program'}</pre>
                                        </div>
                                    `;
                                } else {
                                    evidenceContent = `<div style="color: var(--danger);">Unknown evidence type: ${e.type}</div>`;
                                }

                                return `
                                    <div style="background: var(--bg-tertiary); border-left: 3px solid var(--accent); padding: 0.75rem; margin-bottom: 0.75rem; border-radius: 4px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                            <div style="font-family: 'SF Mono', Monaco, monospace; font-size: 0.7rem; color: var(--accent); font-weight: 600; text-transform: uppercase;">
                                                ${e.type}
                                            </div>
                                        </div>
                                        ${evidenceContent}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : ''}
                    ${claim.uncertainties && claim.uncertainties.length > 0 ? `
                        <div style="border-top: 1px solid var(--border); padding-top: 1rem;">
                            <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--warning);">Uncertainties</div>
                            ${claim.uncertainties.map(u => `
                                <div style="background: rgba(210, 153, 34, 0.1); border-left: 3px solid var(--warning); padding: 0.75rem; margin-bottom: 0.75rem; border-radius: 4px; font-size: 0.85rem; line-height: 1.5;">
                                    ${u}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            } else if (selectedItem.type === 'implication') {
                const impl = hypergraph.implications.find(i => i.id === selectedItem.id);
                if (!impl) return;

                const premiseIds = impl.premises.join(', ');
                const formula = `(${premiseIds}) â†’ ${impl.conclusion}`;

                content.innerHTML = `
                    <div style="margin-bottom: 1rem;">
                        <div style="font-family: 'SF Mono', Monaco, monospace; font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                            ${impl.id}
                        </div>
                        <div style="font-family: 'SF Mono', Monaco, monospace; color: var(--accent); margin-bottom: 0.75rem; font-size: 0.9rem;">
                            ${formula}
                        </div>
                    </div>
                    <div style="border-top: 1px solid var(--border); padding-top: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--accent);">Reasoning</div>
                        <div style="font-size: 0.9rem; line-height: 1.6; color: var(--text-secondary);">
                            ${impl.reasoning}
                        </div>
                    </div>
                `;
            }
        }

        // ALGORITHMIC TREE LAYOUT - NO PHYSICS
        function calculateTreeLayout(visibleClaims, width, height) {
            const levels = new Map();

            // Find root conclusions
            const allPremises = new Set();
            hypergraph.implications.forEach(impl => {
                impl.premises.forEach(p => allPremises.add(p));
            });

            const rootConclusions = visibleClaims
                .filter(c => conclusionToPremises.has(c.id))
                .filter(c => !allPremises.has(c.id))
                .map(c => c.id);

            if (rootConclusions.length === 0) {
                visibleClaims
                    .filter(c => conclusionToPremises.has(c.id))
                    .forEach(c => rootConclusions.push(c.id));
            }

            // Calculate levels (distance from root)
            rootConclusions.forEach(rootId => levels.set(rootId, 0));

            let changed = true;
            let iterations = 0;
            while (changed && iterations < 20) {
                changed = false;
                iterations++;

                hypergraph.implications.forEach(impl => {
                    if (collapsedNodes.has(impl.conclusion) ||
                        impl.premises.some(p => collapsedNodes.has(p))) {
                        return;
                    }

                    const conclusionLevel = levels.get(impl.conclusion);
                    if (conclusionLevel !== undefined) {
                        const junctionId = `junction_${impl.id}`;
                        const junctionLevel = conclusionLevel + 1;
                        const premiseLevel = conclusionLevel + 2;

                        if (!levels.has(junctionId)) {
                            levels.set(junctionId, junctionLevel);
                            changed = true;
                        }

                        impl.premises.forEach(premiseId => {
                            if (!levels.has(premiseId) || levels.get(premiseId) < premiseLevel) {
                                levels.set(premiseId, premiseLevel);
                                changed = true;
                            }
                        });
                    }
                });
            }

            // Calculate subtree widths recursively
            const subtreeWidths = new Map();

            function calculateSubtreeWidth(nodeId, visited = new Set()) {
                if (subtreeWidths.has(nodeId)) return subtreeWidths.get(nodeId);
                if (visited.has(nodeId)) return 150;
                visited.add(nodeId);

                const premises = conclusionToPremises.get(nodeId);
                const visiblePremises = premises ? premises.filter(p => !collapsedNodes.has(p)) : [];

                if (visiblePremises.length === 0) {
                    subtreeWidths.set(nodeId, 150);
                    return 150;
                }

                let totalWidth = 0;
                visiblePremises.forEach(premiseId => {
                    totalWidth += calculateSubtreeWidth(premiseId, visited);
                });
                totalWidth += (visiblePremises.length - 1) * 100; // Spacing

                const width = Math.max(150, totalWidth);
                subtreeWidths.set(nodeId, width);
                return width;
            }

            visibleClaims.forEach(c => calculateSubtreeWidth(c.id));

            // Position nodes recursively
            const positions = new Map();
            const maxLevel = Math.max(...Array.from(levels.values()), 0);
            const levelSpacing = (height - 200) / (maxLevel + 1);

            function positionSubtree(nodeId, centerX, level) {
                const y = 100 + level * levelSpacing;

                // Check if node has a user-defined position already
                if (nodePositions.has(nodeId)) {
                    const userPos = nodePositions.get(nodeId);
                    positions.set(nodeId, userPos);
                } else {
                    positions.set(nodeId, { x: centerX, y });
                }

                const premises = conclusionToPremises.get(nodeId);
                const visiblePremises = premises ? premises.filter(p => !collapsedNodes.has(p)) : [];

                if (visiblePremises.length === 0) return;

                // Position junction
                const impl = hypergraph.implications.find(i => i.conclusion === nodeId);
                if (impl) {
                    const junctionId = `junction_${impl.id}`;
                    const junctionLevel = level + 1;
                    const junctionY = 100 + junctionLevel * levelSpacing;

                    if (nodePositions.has(junctionId)) {
                        positions.set(junctionId, nodePositions.get(junctionId));
                    } else {
                        positions.set(junctionId, { x: centerX, y: junctionY });
                    }
                }

                // Position child subtrees
                const premiseLevel = level + 2;
                const childWidths = visiblePremises.map(p => subtreeWidths.get(p) || 150);
                const premiseSpacing = 50; // Gap between premise nodes
                const totalWidth = childWidths.reduce((a, b) => a + b, 0) + (visiblePremises.length - 1) * premiseSpacing;

                let currentX = centerX - totalWidth / 2;
                visiblePremises.forEach((premiseId, i) => {
                    const childCenterX = currentX + childWidths[i] / 2;
                    positionSubtree(premiseId, childCenterX, premiseLevel);
                    currentX += childWidths[i] + premiseSpacing;
                });
            }

            // Position each root tree
            let totalRootWidth = 0;
            rootConclusions.forEach(rootId => {
                totalRootWidth += subtreeWidths.get(rootId) || 150;
            });
            totalRootWidth += (rootConclusions.length - 1) * 200;

            let rootX = width / 2 - totalRootWidth / 2;
            rootConclusions.forEach(rootId => {
                const rootWidth = subtreeWidths.get(rootId) || 150;
                positionSubtree(rootId, rootX + rootWidth / 2, 0);
                rootX += rootWidth + 200;
            });

            return { positions, levels };
        }

        function renderHypergraph() {
            const width = document.getElementById('graph').clientWidth;
            const height = 800;

            d3.select('#graph').selectAll('*').remove();

            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);

            g = svg.append('g');

            zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom)
                .on('dblclick.zoom', null) // Disable double-click zoom
                .on('dblclick', () => {
                    // Double-click background to unselect
                    if (selectedItem) {
                        selectedItem = null;
                        document.querySelectorAll('.claim-card').forEach(card => {
                            card.classList.remove('selected');
                        });
                        d3.selectAll('.claim-node')
                            .attr('opacity', 1)
                            .attr('stroke-width', 2);
                        d3.selectAll('.hyperedge')
                            .attr('opacity', 0.7)
                            .attr('stroke-width', d => {
                                const baseWidth = d.type === 'junction-to-conclusion' ? 3 : 2;
                                const dx = Math.abs(d.target.x - d.source.x);
                                const isVertical = dx < 5;
                                return isVertical ? baseWidth + 1 : baseWidth;
                            });
                        renderDetailsPanel();
                    }
                });

            // Create nodes (include ALL nodes, we'll hide collapsed ones with CSS)
            const claims = hypergraph.claims.map(c => ({...c, type: 'claim'}));
            const junctions = hypergraph.implications.map(impl => ({
                id: `junction_${impl.id}`,
                type: 'junction',
                implication: impl
            }));

            const allNodes = [...claims, ...junctions];

            // Calculate layout (only for visible nodes)
            const visibleClaims = claims.filter(c => !collapsedNodes.has(c.id));
            const { positions, levels } = calculateTreeLayout(visibleClaims, width, height);

            // Apply positions to nodes
            allNodes.forEach(node => {
                const pos = positions.get(node.id);
                if (pos) {
                    node.x = pos.x;
                    node.y = pos.y;
                } else {
                    // Check if user dragged this node to a custom position
                    const savedPos = nodePositions.get(node.id);
                    if (savedPos) {
                        node.x = savedPos.x;
                        node.y = savedPos.y;
                    } else {
                        // Default position for orphan nodes
                        node.x = width / 2;
                        node.y = height / 2;
                    }
                }
            });

            // Create links
            const links = [];
            hypergraph.implications.forEach(impl => {
                const junctionId = `junction_${impl.id}`;

                if (collapsedNodes.has(impl.conclusion) ||
                    impl.premises.some(p => collapsedNodes.has(p))) {
                    return;
                }

                impl.premises.forEach(premise => {
                    const sourceNode = allNodes.find(n => n.id === premise);
                    const targetNode = allNodes.find(n => n.id === junctionId);
                    if (sourceNode && targetNode) {
                        links.push({
                            source: sourceNode,
                            target: targetNode,
                            type: 'premise-to-junction',
                            premises: impl.premises,
                            conclusion: impl.conclusion,
                            implId: impl.id
                        });
                    }
                });

                const junctionNode = allNodes.find(n => n.id === junctionId);
                const conclusionNode = allNodes.find(n => n.id === impl.conclusion);
                if (junctionNode && conclusionNode) {
                    links.push({
                        source: junctionNode,
                        target: conclusionNode,
                        type: 'junction-to-conclusion',
                        premises: impl.premises,
                        conclusion: impl.conclusion,
                        implId: impl.id
                    });
                }
            });

            // Add defs for markers
            const defs = svg.append('defs');
            const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();

            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 20)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', accentColor);

            const filter = defs.append('filter')
                .attr('id', 'glow')
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');

            filter.append('feGaussianBlur')
                .attr('stdDeviation', '2')
                .attr('result', 'coloredBlur');

            const feMerge = filter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            // Draw links
            function createCurvePath(d) {
                const sourceX = d.source.x;
                const sourceY = d.source.y;
                const targetX = d.target.x;
                const targetY = d.target.y;

                const dx = targetX - sourceX;
                const dy = targetY - sourceY;

                if (d.type === 'premise-to-junction') {
                    const cp1X = sourceX + dx * 0.3;
                    const cp1Y = sourceY + dy * 0.3;
                    const cp2X = targetX - dx * 0.2;
                    const cp2Y = targetY - dy * 0.2;
                    return `M ${sourceX},${sourceY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${targetX},${targetY}`;
                } else {
                    const cp1X = sourceX + dx * 0.3;
                    const cp1Y = sourceY + dy * 0.3 - 15;
                    const cp2X = sourceX + dx * 0.7;
                    const cp2Y = sourceY + dy * 0.7 - 15;
                    return `M ${sourceX},${sourceY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${targetX},${targetY}`;
                }
            }

            const edgeAccentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
            const edgeSecondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();

            const link = g.append('g')
                .selectAll('path')
                .data(links)
                .join('path')
                .attr('class', d => `hyperedge ${d.type}`)
                .attr('d', createCurvePath)
                .attr('stroke', d => d.type === 'junction-to-conclusion' ? edgeAccentColor : edgeSecondaryColor)
                .attr('stroke-width', d => {
                    // Make vertical lines thicker so they're more visible
                    const dx = Math.abs(d.target.x - d.source.x);
                    const isVertical = dx < 5;
                    const baseWidth = d.type === 'junction-to-conclusion' ? 3 : 2;
                    return isVertical ? baseWidth + 1 : baseWidth;
                })
                .attr('opacity', 0.7)
                .attr('fill', 'none')
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .attr('marker-end', d => d.type === 'junction-to-conclusion' ? 'url(#arrowhead)' : null)
                .attr('cursor', 'pointer')
                .on('click', (event, d) => {
                    event.stopPropagation();
                    selectImplication(d.implId);
                });

            // Draw nodes
            const node = g.append('g')
                .selectAll('g')
                .data(allNodes)
                .join('g')
                .attr('class', d => d.type === 'claim' ? 'claim-node' : 'junction-node')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .call(d3.drag()
                    .filter(function(event) {
                        // Don't start drag if clicking on expand indicator
                        return !event.target.closest('.expand-indicator');
                    })
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Render claim nodes
            node.filter(d => d.type === 'claim')
                .append('circle')
                .attr('r', fullTextMode ? 65 : 50)
                .attr('fill', d => getScoreColor(d.score))
                .attr('fill-opacity', 0.6)
                .attr('stroke', d => getScoreColor(d.score))
                .attr('stroke-width', 2)
                .attr('cursor', 'pointer');

            // Add claim text
            node.filter(d => d.type === 'claim')
                .each(function(d) {
                    const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
                    const text = d3.select(this).append('text')
                        .attr('text-anchor', 'middle')
                        .attr('fill', textColor)
                        .attr('font-size', fullTextMode ? '10px' : '11px')
                        .attr('font-weight', '500')
                        .attr('pointer-events', 'none');

                    const words = d.text.split(/\s+/);
                    const maxWidth = fullTextMode ? 110 : 85;
                    const lineHeight = fullTextMode ? 11 : 12;
                    const maxLines = fullTextMode ? 10 : 4;

                    let line = [];
                    let lineNumber = 0;
                    let tspan = text.append('tspan')
                        .attr('x', 0)
                        .attr('dy', 0);

                    for (let i = 0; i < words.length; i++) {
                        line.push(words[i]);
                        tspan.text(line.join(' '));

                        if (tspan.node().getComputedTextLength() > maxWidth) {
                            if (!fullTextMode && lineNumber >= maxLines - 1) {
                                line.pop();
                                tspan.text(line.join(' ') + '...');
                                break;
                            }
                            line.pop();
                            tspan.text(line.join(' '));
                            line = [words[i]];
                            lineNumber++;
                            tspan = text.append('tspan')
                                .attr('x', 0)
                                .attr('dy', lineHeight)
                                .text(words[i]);
                        }
                    }

                    const totalHeight = (lineNumber + 1) * lineHeight;
                    text.attr('transform', `translate(0, ${-totalHeight / 2 + 5})`);
                });

            // Add expand/collapse indicator
            node.filter(d => d.type === 'claim' && isConclusion(d.id))
                .each(function(d) {
                    const parentG = d3.select(this);
                    const radius = fullTextMode ? 65 : 50;

                    // Create a group for the indicator button
                    const indicatorG = parentG.append('g')
                        .attr('class', 'expand-indicator')
                        .attr('cursor', 'pointer')
                        .on('click', function(event) {
                            event.stopPropagation(); // Don't trigger parent click
                            toggleCollapse(d.id);
                        })
                        .on('dblclick', function(event) {
                            event.stopPropagation(); // Prevent zoom on double-click
                        });

                    const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
                    const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
                    const junctionBg = getComputedStyle(document.documentElement).getPropertyValue('--junction-bg').trim();

                    indicatorG.append('circle')
                        .attr('cx', radius * 0.6)
                        .attr('cy', radius * 0.6)
                        .attr('r', 12)
                        .attr('fill', accentColor)
                        .attr('stroke', textColor)
                        .attr('stroke-width', 2);

                    const isCollapsed = arePremisesCollapsed(d.id);
                    indicatorG.append('text')
                        .attr('class', 'expand-symbol')
                        .attr('x', radius * 0.6)
                        .attr('y', radius * 0.6)
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('fill', junctionBg)
                        .attr('font-size', '14px')
                        .attr('font-weight', '700')
                        .attr('pointer-events', 'none')
                        .text(isCollapsed ? '+' : 'âˆ’');
                });

            // Render junction nodes
            node.filter(d => d.type === 'junction')
                .append('circle')
                .attr('r', 8)
                .attr('fill', d => d.implication.type === 'OR' ? '#d29922' : '#58a6ff')
                .attr('stroke', d => d.implication.type === 'OR' ? '#d29922' : '#58a6ff')
                .attr('stroke-width', 2)
                .attr('opacity', 0.9)
                .attr('cursor', 'pointer');

            const junctionTextColor = getComputedStyle(document.documentElement).getPropertyValue('--junction-bg').trim();

            node.filter(d => d.type === 'junction')
                .append('text')
                .text(d => d.implication.type === 'OR' ? 'âˆ¨' : 'âˆ§')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                .attr('fill', junctionTextColor)
                .attr('font-size', '12px')
                .attr('font-weight', '700')
                .attr('pointer-events', 'none');

            // Click handler for junction nodes
            node.filter(d => d.type === 'junction')
                .on('click', (event, d) => {
                    event.stopPropagation();
                    selectImplication(d.implication.id);
                });

            // Tooltips
            node.filter(d => d.type === 'claim')
                .append('title')
                .text(d => `${d.id}\n${d.text}\nScore: ${d.score}/10`);

            node.filter(d => d.type === 'junction')
                .append('title')
                .text(d => {
                    const type = d.implication.type || 'AND';
                    const symbol = type === 'OR' ? 'âˆ¨' : 'âˆ§';
                    return `${type} junction\n${d.implication.id}: ${d.implication.premises.join(` ${symbol} `)} â†’ ${d.implication.conclusion}`;
                });

            // Click handler - just select the claim (expand/collapse handled by +/- button)
            node.filter(d => d.type === 'claim')
                .on('click', (event, d) => {
                    selectClaim(d.id);
                });

            // Apply initial visibility based on collapsed state
            updateNodeVisibility();
        }

        // Simple drag handlers - just update position and re-render
        let draggedNode = null;

        function dragstarted(event, d) {
            draggedNode = d;
            d3.select(this).raise().attr('cursor', 'grabbing');
        }

        function dragged(event, d) {
            d.x = event.x;
            d.y = event.y;

            // Store user-defined position
            nodePositions.set(d.id, { x: d.x, y: d.y });

            // Update this node's position
            d3.select(this).attr('transform', `translate(${d.x},${d.y})`);

            // Update connected links
            d3.selectAll('.hyperedge').attr('d', function(linkData) {
                const sourceX = linkData.source.x;
                const sourceY = linkData.source.y;
                const targetX = linkData.target.x;
                const targetY = linkData.target.y;

                const dx = targetX - sourceX;
                const dy = targetY - sourceY;

                if (linkData.type === 'premise-to-junction') {
                    const cp1X = sourceX + dx * 0.3;
                    const cp1Y = sourceY + dy * 0.3;
                    const cp2X = targetX - dx * 0.2;
                    const cp2Y = targetY - dy * 0.2;
                    return `M ${sourceX},${sourceY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${targetX},${targetY}`;
                } else {
                    const cp1X = sourceX + dx * 0.3;
                    const cp1Y = sourceY + dy * 0.3 - 15;
                    const cp2X = sourceX + dx * 0.7;
                    const cp2Y = sourceY + dy * 0.7 - 15;
                    return `M ${sourceX},${sourceY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${targetX},${targetY}`;
                }
            });
        }

        function dragended(event, d) {
            d3.select(this).attr('cursor', 'pointer');
            draggedNode = null;
        }

        function renderOutline() {
            const outlineEl = document.getElementById('outline');
            outlineEl.innerHTML = '';

            // Build tree structure
            // Find root nodes (conclusions that are not premises)
            const allPremises = new Set();
            hypergraph.implications.forEach(impl => {
                impl.premises.forEach(p => allPremises.add(p));
            });

            const rootClaims = hypergraph.claims
                .filter(c => conclusionToPremises.has(c.id))
                .filter(c => !allPremises.has(c.id));

            if (rootClaims.length === 0) {
                // If no clear roots, show all conclusions
                rootClaims.push(...hypergraph.claims.filter(c => conclusionToPremises.has(c.id)));
            }

            // Render each root
            rootClaims.forEach(claim => {
                outlineEl.appendChild(renderOutlineNode(claim));
            });

            // Add event handlers
            outlineEl.querySelectorAll('.outline-claim').forEach(el => {
                el.addEventListener('click', (e) => {
                    if (!e.target.closest('.outline-expand')) {
                        const claimId = el.dataset.claimId;
                        selectClaim(claimId);

                        // Update selection UI in outline
                        outlineEl.querySelectorAll('.outline-claim').forEach(c => {
                            c.classList.toggle('selected', c.dataset.claimId === claimId);
                        });
                    }
                });
            });

            outlineEl.querySelectorAll('.outline-expand').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const claimId = el.dataset.claimId;
                    toggleOutlineCollapse(claimId);
                });
            });
        }

        function renderOutlineNode(claim, visited = new Set()) {
            // Prevent infinite recursion
            if (visited.has(claim.id)) {
                const node = document.createElement('div');
                node.className = 'outline-node';
                node.innerHTML = '<div style="color: var(--warning); font-size: 0.8rem;">â†» Circular reference</div>';
                return node;
            }
            visited.add(claim.id);

            const node = document.createElement('div');
            node.className = 'outline-node';

            const premises = conclusionToPremises.get(claim.id);
            const hasPremises = premises && premises.length > 0;
            const isCollapsed = outlineCollapsedNodes.has(claim.id);

            const scoreColor = getScoreColor(claim.score);

            node.innerHTML = `
                <div class="outline-claim" data-claim-id="${claim.id}" style="border-left-color: ${scoreColor};">
                    ${hasPremises ? `
                        <div class="outline-expand" data-claim-id="${claim.id}">
                            ${isCollapsed ? '+' : 'âˆ’'}
                        </div>
                    ` : '<div style="width: 20px;"></div>'}
                    <div class="outline-content">
                        <div class="outline-id">${claim.id}</div>
                        <div class="outline-text">${claim.text}</div>
                        <span class="outline-score ${getScoreClass(claim.score)}">${claim.score}/10</span>
                    </div>
                </div>
            `;

            // Add children if not collapsed
            if (hasPremises && !isCollapsed) {
                const impl = hypergraph.implications.find(i => i.conclusion === claim.id);
                if (impl) {
                    const childrenDiv = document.createElement('div');
                    childrenDiv.className = 'outline-children';

                    // Add implication info
                    const implDiv = document.createElement('div');
                    implDiv.className = 'outline-implication';
                    implDiv.textContent = `${impl.type} relationship: ${impl.reasoning}`;
                    childrenDiv.appendChild(implDiv);

                    // Render child nodes
                    premises.forEach(premiseId => {
                        const premiseClaim = hypergraph.claims.find(c => c.id === premiseId);
                        if (premiseClaim) {
                            childrenDiv.appendChild(renderOutlineNode(premiseClaim, new Set(visited)));
                        }
                    });

                    node.appendChild(childrenDiv);
                }
            }

            return node;
        }

        function toggleOutlineCollapse(claimId) {
            if (outlineCollapsedNodes.has(claimId)) {
                outlineCollapsedNodes.delete(claimId);
            } else {
                outlineCollapsedNodes.add(claimId);
            }
            renderOutline();
        }

        function resetView() {
            selectedItem = null;
            nodePositions.clear();

            document.querySelectorAll('.claim-card').forEach(card => {
                card.classList.remove('selected');
            });

            if (viewMode === 'graph') {
                d3.selectAll('.claim-node')
                    .attr('opacity', 1)
                    .attr('stroke-width', 2);

                d3.selectAll('.hyperedge')
                    .attr('opacity', 0.7);
            } else {
                document.querySelectorAll('.outline-claim').forEach(el => {
                    el.classList.remove('selected');
                });
            }

            renderDetailsPanel();
            renderCurrentView();
        }

        function toggleTextMode() {
            fullTextMode = !fullTextMode;
            const button = document.getElementById('toggle-text');
            button.textContent = fullTextMode ? 'Compact Text' : 'Full Text';
            if (viewMode === 'graph') {
                renderHypergraph();
            }
            // Outline view doesn't use fullTextMode
        }

        function zoomBy(factor) {
            if (!svg || !zoom) return;
            svg.transition()
                .duration(300)
                .call(zoom.scaleBy, factor);
        }

        function resetZoom() {
            if (!svg || !zoom) return;
            svg.transition()
                .duration(500)
                .call(zoom.transform, d3.zoomIdentity);
        }
    </script>
</body>
</html>
